import math
import numpy as np
from scipy.fft import fft, ifft
from scipy.signal import butter, lfilter, cheby2, cheby1


# # # # # # # # # # # # # # #
# Формирование одного чипа* #
# (функция-обертка)         #
# # # # # # # # # # # # # # #

# *чип - один период модулирующего сигнала (в рамках данной ЛР)

def generate_single_chip(signal_type: str, *signal_data):
    """
    Сформировать отсчеты одного периода одного из следующих сигналов:
    видеоимпульс `video`, радиоимпульс `radio`, АМ-сигнал `AM`, ЛЧМ- 
    сигнал `chirp`. Для каждого из видов сигнала необходимо передать 
    в функцию разный набор параметров. Функция представляет собой 
    обертку вокруг функций, которые непосредственно формируют сигналы.
    
    Parameters
    ----------       
    signal_type : 'video', 'radio', 'AM', 'chirp'
        Вид сигнала, отсчеты которого необходимо сформировать.
    *signal_data : number of scalars
        Набор параметров, которые необходимо передать для формирования
        требуемого вида сигнала. 
        Для видеоимпульса 'video': `t_d`, `t_window`, `t_imp`;
        Для радиоимпульса 'radio': `t_d`, `t_window`, `t_imp`, `f_carrier_hz`;
        Для AM: `t_d`, `t_window`, 'f_carrier_hz', `f_mod_hz`, `i_mod`;
        Для ЛЧМ: `t_d`, `t_window`, `t_imp`, `f_start_hz`, `f_chirp_hz`,
        где 
            `t_d` - интервал дискретизации сигнала;
            `t_window` - интервал наблюдения сигнала;
            `t_imp` - длительность огибающей импульса;
            `f_carrier_hz` - частота заполнения сигнала;
            `f_mod_hz` - частота модулирующего сигнала;
            `i_mod` - глубина модуляции (индекс модуляции);
            `f_start_hz` - центральная частота ЛЧМ-сигнала;
            `f_chirp_hz` - частота девиации ЛЧМ-сигнала.
    Returns
    -------
    signal : array_like
        Набор отсчетов сигнала требуемого типа.
    
    Raises
    -------
    ValueError
        Если в аргумент `signal_type `был передан неверный тип сигнала.

    """

    # Выбор вызываемой функции в зависимости от значения sig_type
    if (signal_type == 'video'):    # тип в/импульс
        signal = get_video_pulse(*signal_data)
    elif (signal_type == 'radio'):  # тип р/импульс
        signal = get_radio_pulse(*signal_data)
    elif (signal_type == 'AM'): # тип АМ-сигнал  
        signal = get_AM(*signal_data)
    elif (signal_type == 'chirp'):  # тип ЛЧМ-сигнал
        signal = get_chirp_pulse(*signal_data)
    else:
        raise ValueError("Введён неверный тип сигнала. Допустимы значения: 'video', 'radio', 'AM', 'chirp'")
    
    return signal


# # # # # # # # # # # # # # #
# Функции формирования чипа #
# # # # # # # # # # # # # # #

# Формирование одного периода в/импульса
def get_video_pulse(t_d: int | float,
                    t_window: int | float,
                    t_imp: int | float):
    """
    Сформировать отсчеты видеоимпульса единичной амплитуды. 
    Он будет помещен в самом начале "временной" оси.
    
    Parameters
    ----------       
    t_d : scalar
        Интервал дискретизации сигнала.
    t_window : scalar
        Длительность "окна", в котором наблюдается сигнал.
    t_imp : scalar
        Длительность создаваемого импульса.
    
    Returns
    -------
    signal : array_like
        Набор отсчетов видеоимпульса.
    """

    n_signal = math.floor(t_window/t_d)  # число отсчетов в рассматриваемом интерв.
    n_imp = math.floor(t_imp/t_d)        # число отсчетов импульса
    signal = [0] * n_signal              # сформировать пустую выборку
    for i in range(0, n_imp):   # первые n_imp отсчетов имеют единичную амплитуду.
        signal[i] = 1
    return signal


# Формирование одного периода р/импульса
def get_radio_pulse(t_d: int | float,
                t_window: int | float,
                t_imp: int | float,
                f_carrier_hz: int | float):
    """
    Сформировать отсчеты радиоимпульса единичной амплитуды. 
    Он будет помещен в самом начале "временной" оси.
    
    Parameters
    ----------       
    t_d : scalar
        Интервал дискретизации сигнала.
    t_window : scalar
        Длительность "окна", в котором наблюдается сигнал.
    t_imp : scalar
        Длительность создаваемого импульса.
    f_carrier_hz : scalar
        Частота несущей, "заполняющей" видеосигнал.

    Returns
    -------
    signal : array_like
        Набор отсчетов радиоимпульса.
    """
    
    n_signal = math.floor(t_window/t_d) # число отсчетов в рассматриваемом интерв.
    n_imp = math.floor(t_imp/t_d)   # число отсчетов импульса
    pulse_amp = [0] * n_signal  # сформировать пустую выборку
    for i in range(1, n_imp):   # сформировать огибающую радиоимпульса
        pulse_amp[i] = 1
    t_axis = np.linspace(0, t_window, n_signal) # формирование временной оси
    carrier = np.sin(2*math.pi*f_carrier_hz*t_axis) # сформировать несущую
    signal = pulse_amp*carrier  # несущая на амплитудные значения
    return signal


# Формирование одного периода АМ-сигнала
def get_AM(t_d: int | float,
        t_window: int | float,
        f_carrier_hz: int | float,
        f_mod_hz: int | float,
        i_mod: int | float):
    """
    Сформировать отсчеты АМ-сигнала.
    
    Parameters
    ----------       
    t_d : scalar
        Интервал дискретизации сигнала.
    t_window : scalar
        Длительность "окна", в котором наблюдается сигнал.
    t_imp : scalar
        Длительность создаваемого импульса.
    f_carrier_hz : scalar
        Частота несущей, "заполняющей" видеосигнал.
    f_mod_hz : scalar
        Частота модулирующей синусоиды.
    i_mod : scalar
        Индекс (глубина) модуляции сигнала

    Returns
    -------
    signal : array_like
        Набор отсчетов АМ-сигнала.
    """

    n_signal = math.floor(t_window/t_d) # число отсчетов в интервале рассмот.
    t_axis = np.linspace(0, t_window, n_signal) # ось времени
    am_mult = 1/(2/i_mod) 
    am_shift = 1-am_mult    # множитель для расчета огибающей АМ
    a_modulation = np.sin(2*math.pi*f_mod_hz*t_axis)*am_mult+am_shift   # огибающая
    signal = np.sin(2*math.pi*f_carrier_hz*t_axis) * a_modulation   # формирование АМ-сигнала

    return signal


# Формирование одного периода ЛЧМ-сигнала
def get_chirp_pulse(t_d: int | float,
                t_window: int | float,
                t_imp: int | float, 
                f_start_hz: int | float, 
                f_chirp_hz: int | float):
    """
    Сформировать отсчеты ЛЧМ-сигнала (в разработке).
    
    Parameters
    ----------       
    t_d : scalar
        Интервал дискретизации сигнала.
    t_window : scalar
        Длительность "окна", в котором наблюдается сигнал.
    t_imp : scalar
        Длительность создаваемого импульса.
    f_start_hz : scalar
        Начальная (и по совместительству - несущая) частота сигнала.
    f_chirp_hz : scalar
        Частота девиации.

    Returns
    -------
    signal : array_like
        Набор отсчетов ЛЧМ-сигнала.
    """

    n_signal = math.floor(t_window/t_d) # число отсчетов в рассматриваемом интерв.
    n_imp = math.floor(t_imp/t_d)   # число отсчетов импульса
    t_axis = np.linspace(0, t_imp, n_imp)   # формирование временной оси
    chirp_band = f_chirp_hz/t_imp   # Определение полосы ЛЧМ-сигнала
    chirp_sin_arg = f_start_hz + chirp_band/2*t_axis    # Множитель аргумента в функции
                                                        # синусоиды
    signal = [0] * n_signal # Инициализация массива выходных значений требуемого
                            # размера
    signal[1:n_imp+1] = np.sin(2*math.pi*chirp_sin_arg*t_axis)  # сформировать несущую
    
    return signal


# # # # # # # # # # # #
# Функции фильтрации  #
# # # # # # # # # # # #

# Применить к сигналу фильтр с "идеальной" АЧХ
def apply_ideal_filter(t_d: int | float, 
                       filter_type: str, 
                       f_cut_hz: int | float | list, 
                       signal_in: list):
    """
    Применить к сигналу один из фильтров (ФНЧ, ФВЧ, ЗФ, ПФ) с 
    идеальной АЧХ (1 - в полосе пропускания, 0 - в полосе подавления, 
    переходной полосы нет). Принцип работы следующий: формируется
    идеальная АЧХ фильтра в области положительных частот, а затем
    с помощью `np.flip()` и конкатенации получается АЧХ для всего
    диапазона частот (и положительных, и отрицательных). Для получения
    выходного сигнала производится перемножение АЧХ фильтра с АЧХ входного
    сигнала.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    signal_in : array_like (real)
        Отсчеты входного действительного сигнала.  
    
    Returns
    -------
    Функция возвращает отсчеты отфильтрованного идеальным `filter_type` 
    фильтром сигнала `signal_in`.

    Raises
    ------
    TypeError:
        Если в функцию было передано неправильное название фильтра
        или граничные частоты фильтра. Или выходной сигнал получился
        комплексным.
    
    ValueError:
        Если в случае фильтра с двумя частотами среза список частот
        не был упорядочен в порядке возрастания.          
    """

    f_d = 1/t_d    # вычисление частоты дискретизации (обратно пропорционально интервалу дискретизации)
    n_signal = len(signal_in) # определение числа отсчетов
    f_axis = np.linspace(0, f_d/2, int(np.floor(n_signal / 2))) # половина набора отсчетов оси абсцисс АЧХ.
                                                                # Вторая половина будет получена с помощью
                                                                # np.flip().
    filter_f_char = np.ones(int(np.ceil((n_signal+1)/2)))   # половина набора отсчетов оси ординат АЧХ.
                                                            # Вторая половина будет получена с помощью
                                                            # np.flip().
    
    if isinstance(f_cut_hz, float or int): # Если одно значение частоты среза, то это будет или ФНЧ, или ФВЧ.
           
        f_cut_i = np.argmax(f_axis > f_cut_hz)  # Выражение f_axis > f_cut_hz дает логический массив, элементами
                                                # которого являются результат сравнения значения f_axis с f_cut_hz
                                                # np.argmax() находит индекс первого максимального значения, который
                                                # будет соответствовать номеру элемента, в котором расположилась 
                                                # частота среза. Такая на первый взгляд сложность обусловлена тем, 
                                                # что число отсчетов входного сигнала не является постоянным, как и
                                                # частота среза.
        if (filter_type == 'HP'): 
            filter_f_char[:f_cut_i] = 0     # Если необходимо сформировать ФВЧ, то все отсчеты АЧХ, сответствующие
                                            # частотам ниже частоты среза должны быть равны нулю.
        elif (filter_type == 'LP'): 
            filter_f_char[f_cut_i:] = 0     # Если необходимо сформировать ФНЧ, то все отсчеты АЧХ, соответствующие  
                                            # частотам выше частоты среза должны быть равны нулю.
        else:   
            raise ValueError('Ошибка вввода: Тип фильтра')  # Вызов исключения, если был передан неизвестный
                                                            # аргумент.
    
    elif isinstance(f_cut_hz, list):    # Если два значения частоты среза, то ПФ или ЗФ
        
        if f_cut_hz[0] > f_cut_hz[1]:   # Для корректной работы необходимо, чтобы нулевой 
                                        # элемент массива частот был меньше первого.
            raise ValueError('Ошибка: f_cut_hz[0] должна быть меньше f_cut_hz[1]')
        
        # TODO: Реализовать ветки, в которых создается положительная область АЧХ 
        # полосового и заградительного фильтров
        if (filter_type == 'BP'):
            pass
        elif (filter_type == 'BS'): 
            pass
        else:   
            raise ValueError('Ошибка вввода: Тип фильтра')  # Вызов исключения, если был передан неизвестный
                                                            # аргумент.
    else:
        raise ValueError('Ошибка ввода: Граничные частоты фильтра')  # В эту ветку код свалится, если f_cut_hz имело
                                                                    # тип данных, который не ожидался (в идеале ожидается)
                                                                    # либо скаляр (int/float) или list из 2 элементов
    
    # Формирование полного массива АЧХ (создание отрицательной частотной области 
    # и конкатенация с существующей положительной)
    tmp_filter_f_char = np.flip(filter_f_char[1:])  # "Переворот" массива АЧХ, поскольку АЧХ в отрицательной области 
                                                    # частот "зеркальна" АЧХ в положительной области.
                                                    # Опускаем 0-й элемент, поскольку в противном случае получится
                                                    # два отсчета, отвечающих за значение АЧХ на нулевой частоте.
    if (n_signal % 2 == 0):
        tmp_filter_f_char = tmp_filter_f_char[:len(tmp_filter_f_char) - 1]  # Если количество отсчетов сигнала четное, то
                                                                            # необходимо исключить последний отсчет АЧХ, т.к
                                                                            # он лишний, а появился из-за выбранного способа
                                                                            # формирования массива filter_f_char (мы округляли)
                                                                            # "вверх" число элементов этого массива.
    filter_f_char = np.append(filter_f_char, tmp_filter_f_char) # Конкатенация отрицательной и положительной 
                                                                # частей АЧХ в один массив.
    
    # Фильтрация входного сигнала
    signal_in_sp = fft(signal_in, n_signal) # АФЧХ входного сигнала
    signal_out_sp = signal_in_sp * filter_f_char    # АФЧХ выходного сигнала (произведение)
                                                    # АФЧХ выходного сигнала на АФЧХ фильтра
    signal_out = ifft(signal_out_sp, n_signal)  # Выходной сигнал во временно`й области
 
    return np.real(signal_out)


# Применить к сигналу фильтр Баттерворта
def apply_butt_filter(t_d: int | float, 
                    filter_type: str, 
                    f_cut_hz: int | float | list,
                    filter_order: int, 
                    signal_in: list):
    """
    Применить к сигналу один из фильтров (ФНЧ, ФВЧ, ЗФ, ПФ) с 
    максимально гладкой АЧХ (фильтр Баттерворта). Функция опирается 
    на библиотечные функции по определению коэффициентов фильтра, 
    а также непосредственно фильтрации сигнала.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    filter_order : scalar
        Порядок фильтра. Чем выше порядок, тем круче спад АЧХ в переходной 
        полосе.
    signal_in : array_like (real)
        Отсчеты входного действительного сигнала.  
    
    Returns
    -------
    Функция возвращает отсчеты сигнала `signal_in` после прохождения через фильтр
    Баттерворта типа `filter_type`.         
    """

    # Формирование коэффициентов числителя и знаменателя 
    # передаточной функции фильтра Баттерворта
    b, a = create_butt_filter(t_d, filter_type, f_cut_hz, filter_order)  
    
    signal_out = lfilter(b, a, signal_in)   # фильтрация сигнала
    return signal_out


# Применить к сигналу фильтр Чебышёва
def apply_cheb2_filter(t_d: int | float, 
                    filter_type: str, 
                    f_cut_hz: int | float | list,
                    filter_order: int, 
                    bnd_att_db: int | float,
                    signal_in: list):
    """
    Применить к сигналу один из фильтров (ФНЧ, ФВЧ, ЗФ, ПФ) с 
    АЧХ, описываемой полиномом Чебышева II типа (фильтр Чебышева).
    Функция опирается на библиотечные функции по определению 
    коэффициентов фильтра, а также непосредственно фильтрации сигнала.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    filter_order : scalar
        Порядок фильтра. Чем выше порядок, тем круче спад АЧХ в переходной 
        полосе.
    bnd_att_db : scalar
        Величина подавления вне полосы пропускания.
    signal_in : array_like (real)
        Отсчеты входного действительного сигнала.  
    
    Returns
    -------
    Функция возвращает отсчеты сигнала `signal_in` после прохождения через фильтр
    Чебышева II рода типа `filter_type`.         
    """

    # Формирование коэффициентов числителя и знаменателя 
    # передаточной функции фильтра Чебышева II рода
    b, a = create_cheb2_filter(t_d, filter_type, f_cut_hz, filter_order, bnd_att_db)
    
    signal_out = lfilter(b, a, signal_in)   # фильтрация сигнала
    return signal_out


# Расчет коэффициентов фильтра Баттерворта
def create_butt_filter(t_d: int | float, 
                    filter_type: str, 
                    f_cut_hz: int | float | list,
                    filter_order: int):
    """
    Определить коэффициенты передаточной функции фильтра с максимально
    гладкой АЧХ (фильтра Баттерворта). Функция опирается на библиотечные
    функции по определению коэффициентов фильтра.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    filter_order : scalar
        Порядок фильтра. Чем выше порядок, тем круче спад АЧХ в переходной 
        полосе.
    
    Returns
    -------
    Функция возвращает коэффициенты числителя `a` и знаменателя `b` передаточной
    функции фильтра. 

    Raises
    -------
    ValueError: 
        Если введён неправильный тип фильтра.     
    """

    # Ветка условий конвертирует обозначения фильтров, которые используются
    # в лабе, в значения, требующиеся библиотечной функции.
    if isinstance(f_cut_hz, float or int):  # если передано одно зачение частоты среза, то:
        if (filter_type == 'LP'):
            f_name = 'lowpass'  # НЧ фильтр
        elif (filter_type == 'HP'):
            f_name = 'highpass' # ВЧ фильтр
        else:
            # если передано неправильное название фильтра
            raise ValueError('Ошибка вввода: Тип фильтра')

    elif (isinstance(f_cut_hz, list)): # если передано несколько значений частот среза, то:
        if (filter_type == 'BP'):
            f_name = 'bandpass' # полосовой фильтр
        elif (filter_type == 'BS'):
            f_name = 'bandstop' # заградительный фильтр
        else:
            # если передано неправильное название фильтра
            raise ValueError('Ошибка вввода: Тип фильтра')

    else:
        # Если что-то не так с переданными частотами среза фильтра
        raise ValueError('Ошибка ввода: Граничные частоты фильтра') 
    
    f_d = 1/t_d # частота дискретизации
    w_n = np.array(f_cut_hz)/(f_d/2)    # нормированная частота среза.
                                        # Нужна для работы библиотечной функции
    b, a = butter(filter_order, w_n, f_name)    # формирование коэффициентов числителя и знаменателя 
                                                # передаточной функции фильтра Баттерворта с использованием
                                                # библиотечной функции
    return b, a


# Расчет коэффициентов Фильтра Чебышева II рода
def create_cheb2_filter(t_d: int | float, 
                    filter_type: str, 
                    f_cut_hz: int | float | list,
                    filter_order: int, 
                    bnd_att_db: int | float):
    """
    Определить коэффициенты передаточной функции фильтра, описываемого полиномом
    Чебышева II рода (фильтра Чебышева II рода). У данного фильтра присутствуют 
    пульсации АЧХ в `полосе заграждения`. `Полоса пропускания` при этом гладкая. 
    Функция опирается на библиотечные функции по определению коэффициентов фильтра.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    filter_order : scalar
        Порядок фильтра. Чем выше порядок, тем круче спад АЧХ в переходной 
        полосе.
    
    Returns
    -------
    Функция возвращает коэффициенты числителя `a` и знаменателя `b` передаточной
    функции фильтра. 

    Raises
    -------
    ValueError: 
        Если введён неправильный тип фильтра.     
    """

    # Ветка условий конвертирует обозначения фильтров, которые используются
    # в лабе, в значения, требующиеся библиотечной функции.
    if isinstance(f_cut_hz, float or int):  # если передано одно зачение частоты среза, то:
        if (filter_type == 'LP'):
            f_name = 'lowpass'  # НЧ фильтр
        elif (filter_type == 'HP'):
            f_name = 'highpass' # ВЧ фильтр
        else:
            # если передано неправильное название фильтра
            raise ValueError('Ошибка вввода: Тип фильтра')

    elif (isinstance(f_cut_hz, list)): # если передано несколько значений частот среза, то:
        if (filter_type == 'BP'):
            f_name = 'bandpass' # полосовой фильтр
        elif (filter_type == 'BS'):
            f_name = 'bandstop' # заградительный фильтр
        else:
            # если передано неправильное название фильтра
            raise ValueError('Ошибка вввода: Тип фильтра')

    else:
        # Если что-то не так с переданными частотами среза фильтра
        raise ValueError('Ошибка ввода: Граничные частоты фильтра') 

    f_d = 1/t_d # частота дискретизации, Гц
    w_n = np.array(f_cut_hz)/(f_d/2)    # нормированная частота среза (w/w_d). Нужна 
                                        # для работы библиотечной функции.
    b, a = cheby2(filter_order, bnd_att_db, w_n, f_name)    # формирование фильтра с помощью библиотечной функции.
    return b, a


# Расчет коэффициентов Фильтра Чебышева I рода
def create_cheb1_filter(t_d: int | float, 
                    filter_type: str, 
                    f_cut_hz: int | float | list,
                    filter_order: int, 
                    bnd_att_db: int | float):
    """
    Определить коэффициенты передаточной функции фильтра, описываемого полиномом
    Чебышева I рода (фильтра Чебышева I рода). У данного фильтра присутствуют пульсации
    АЧХ в `полосе пропускания`. `Полоса заграждения` при этом гладкая.
    Функция опирается на библиотечные функции по определению коэффициентов фильтра.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    filter_order : scalar
        Порядок фильтра. Чем выше порядок, тем круче спад АЧХ в переходной 
        полосе.
    
    Returns
    -------
    Функция возвращает коэффициенты числителя `a` и знаменателя `b` передаточной
    функции фильтра. 

    Raises
    -------
    ValueError: 
        Если введён неправильный тип фильтра или список частот.     
    """

    # Ветка условий конвертирует обозначения фильтров, которые используются
    # в лабе, в значения, требующиеся библиотечной функции.
    if isinstance(f_cut_hz, float or int):  # если передано одно зачение частоты среза, то:
        if (filter_type == 'LP'):
            f_name = 'lowpass'  # НЧ фильтр
        elif (filter_type == 'HP'):
            f_name = 'highpass' # ВЧ фильтр
        else:
            # если передано неправильное название фильтра
            raise ValueError('Ошибка вввода: Тип фильтра')

    elif (isinstance(f_cut_hz, list)): # если передано несколько значений частот среза, то:
        if (filter_type == 'BP'):
            f_name = 'bandpass' # полосовой фильтр
        elif (filter_type == 'BS'):
            f_name = 'bandstop' # заградительный фильтр
        else:
            # если передано неправильное название фильтра
            raise ValueError('Ошибка вввода: Тип фильтра')

    else:
        # Если что-то не так с переданными частотами среза фильтра
        raise ValueError('Ошибка ввода: Граничные частоты фильтра') 
        
    f_d = 1/t_d # частота дискретизации, Гц
    w_n = np.array(f_cut_hz)/(f_d/2)    # нормированная частота среза (w/w_d). Нужна для
                                        # работы библиотечной функции
    b, a = cheby1(filter_order, bnd_att_db, w_n, f_name)    # вычисление коэффициентов передаточной
                                                            # функции фильтра
    return b, a
