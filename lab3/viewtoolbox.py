import matplotlib.pyplot as plt
import numpy as np
from scipy.fft import fft, fftshift
from scipy.signal import lfilter, freqz


# # # # # # # # # # # # #
# Отображение сигналов  #
# # # # # # # # # # # # #

# Временная область
def plot_signal(signal_args: list[list]) -> None:
    """
    Вывести действительную часть сигнала, в случае необходимости вывода
    нескольких линий на один график, они передаются в качестве второй
    размерности массива, типа: [[`signal_args` первой линии графика], 
    [`signal_args` второй линии]]. Одинаковая размерность не обязательна.
    В зависимости от числа переданных аргументов (размерности `signal_args`), 
    функция распознает их следующим образом:

    Parameters
    ----------
    signal_args : array_like
                  Значения по оси ординат (ось OY). В таком случае по оси абсцис (ось OX)
                  будут отложены номера отсчетов.
    signal_args : [array_like or scalar, array_like]
                  Набор значений оси абсцисс или частота дискретизации 
                  в качестве первого аргумента. Значения амплитуд для 
                  оси ординат - в качестве второго.
    signal_args : [array_like or scalar, array_like, string]
                  Первые два аргумента подразумеваются такими же, что и для случая выше. В
                  качестве третьего аргумента передается название линии (пишется в легенде).
    
    Returns
    -------
    Функция создает графики и ничего не возвращает.

    Raises
    ------
    ValueError:
        Если в функцию было передано неверное число аргументов.
    """

    lines = ["-", "--", "-.", ":"] # Список возможных стилей линий графиков
    leg = []
    plt.figure()
    for i in range (len(signal_args)):  # Цикл по числу линий, переданных в функцию
        
        args_len = len(signal_args[i])  # Определяем, сколько аргументов передано для i-ой линии.
        if (args_len > 3 or args_len < 1): # Если аргументов оказалось не столько, сколько ожидалось.
            raise TypeError('Ошибка ввода. Неверное число аргументов (допускается от 1 до 3 аргументов)')
        if (args_len == 1): # Ветка для случая, когда был передан один аргумент (набор значений оси ординат)
            signal = signal_args[i][0]
            x_axis = range(0, len(signal))
        if (args_len == 2 or args_len == 3):
            signal = signal_args[i][1]
            if (type(signal_args[i][0]) == float): # Если в качестве первого аргумента передан шаг дискретизации
                x_axis = np.arange(0, signal_args[i][0]*(len(signal)), signal_args[i][0])
            else:
                x_axis = signal_args[i][1]                
    
        # Построение i-й линии        
        plt.plot(x_axis*1e6, np.real(signal), linestyle=lines[i])
        
        if (args_len == 3):
            leg.append(signal_args[i][2])
        else:
            leg.append('Безымянный сигнал ' + str(i))   # Если не нравится, можно заменить 
                                                        # содержимое скобок на " ". Работает
                                                        # тоже красиво
        
    plt.legend(leg)
    plt.title('Исходный сигнал')
    plt.xlabel("t, мкc") # ось абсцисс
    plt.ylabel('Амплитуда')
    plt.grid()
    plt.show()


# Частотная область
def plot_spectum(signal_args: list[list]) -> None:
    """
    Построить график модуля БПФ сигнала, в случае необходимости вывода 
    нескольких линий на один график, они передаются в качестве второй 
    размерности массива, типа: [[`signal_args` первой линии], [`signal_args` второй линии]].
    Одинаковая размерность не обязательна.
    
    Parameters
    ----------       
    signal_args : [scalar, array_like]
                  Частота дискретизации в качестве первого аргумента. 
                  Отсчеты сигнала во временной области - в качестве второго.
    signal_args : [scalar, array_like, string]
                  Первые два аргумента подразумеваются такими же, что и для случая выше. В
                  качестве третьего аргумента передается название линии (пишется в легенде).
    
    Returns
    -------
    Функция создает графики и ничего не возвращает.

    Raises
    ------
    TypeError:
        Если в функцию было передано неверное число аргументов.
    """

    t_d_us = signal_args[0][0]*1e6 # Шаг дискретизации, переведенный в микросекунды
    plt.figure()

    for i in range(len(signal_args)):   # Цикл по числу линий, переданных в функцию
        
        args_len = len(signal_args[i])  # Определяем, сколько аргументов передано для i-ой линии.
        if (args_len > 3 or args_len < 2):  # Если аргументов оказалось не столько, сколько ожидалось.
            raise TypeError('Ошибка ввода. Неверное число аргументов (допускается 2 или 3 аргумента)')
        
        signal = signal_args[i][1]  # Массив значений оси ординат
        n_signal = signal.size  # Способ получить число отсчетов (по сути то же самое, что и len())
        t_window = n_signal*t_d_us  # Вычисление размера окна
        f_step_mhz = 1/t_window # Шаг по частоте (нужен для формирования отсчетов оси абсцисс)
        
        # Формируем точки оси абсцисс графика. Сначала формируем
        # область положительных частот, затем путем отзеркаливания
        # формируется область отрицательных частот.
        # В зависимости от того, четное ли число точек в исходном
        # сигнале, или нечетное, "зеркалится" на 1 отсчет больше или
        # меньше
        if n_signal % 2 == 0:
            f_axis = np.arange(0, (n_signal+1)*f_step_mhz/2, f_step_mhz)
            tmp_axis = np.flip(f_axis[2:]) * (-1) 
            f_axis = np.append(tmp_axis, f_axis)
        else:
            f_axis = np.arange(0, (n_signal)*f_step_mhz/2, f_step_mhz)
            tmp_axis = np.flip(f_axis[1:]) * (-1)
            f_axis = np.append(tmp_axis, f_axis)
        
        # БПФ входных отсчетов, нормированное на число отсчетов
        signal_spectrum = 1/n_signal*fft(signal, n_signal)
        
        # Формирование названий линий
        if (len(signal_args[i]) > 2):
            line_label = str(signal_args[i][2])
        else:
            line_label = 'Безымянный спектр ' + str(i)  # Выражение может быть заменено 
                                                        # на: ' '(пробел в кавычках)
            
        plt.plot(f_axis, fftshift(abs(signal_spectrum)), label=line_label)  # построение i-й линии
    plt.title("Спектр") # заголовок
    plt.xlabel("Частота, МГц") # ось абсцисс  
    plt.ylabel('Амплитуда')      
    plt.legend()
    plt.grid()
    plt.show()


# Вывод ИХ фильтра по его коэффициентам
def impz(b: list, a:list, name: str) -> None:
    """
    Вывести график импульсной характеристики на основе переданного набора коэффициентов 
    (полюсов) `a` и `b` передаточной функции.
    
    Parameters
    ----------       
    b : array_like
        Набор коэффициентов (полюсов) знаменателя передаточной функции.
    a : array_like
        Набор коэффициентов (полюсов) числителя передатчоной функции.
    name : string
        Название графика.
    Returns
    -------
    Функция создает графики и ничего не возвращает.
    """

    n_pts = 100 # число точек импульсной характеристики. В функции нет никакого упоминания про
                # частоту дискретизации, поскольку коэффициенты передаточной характеристики
                # никоим образом не определяют абсолютные значения длительности ИХ.

    impulse = [0]*n_pts # impulse - массив отсчетов входного воздействия на фильтр (импульса).
                        # [0]*100 - это способ задать 100 одинаковых элементов (в данном
                        # случае - нулей)

    impulse[0] = 1. # Один из ста отсчетов будет иметь единичное значение. Получится своеобразный
                    # импульс.

    x = range(n_pts)    # Набор значений оси абсцисс для построения графика
    response = lfilter(b, a, impulse)   # Библиотечная функция вычисления отлика фильтра с полюсами
                                        # передаточной хар-ки 'a', 'b' на входное воздействие 'impulse'
    plt.figure()
    plt.stem(x, response)
    plt.ylabel('Амплитуда')
    plt.xlabel(r'n (отсчёты)')
    plt.grid()
    plt.title(name)
    plt.show()


# Вывод АЧХ и ФЧХ одного фильтра по его коэффициентам
def mfreqz(b: list, a: list, lims=[0,1]) -> None:
    """
    Вывести графики АЧХ и ФЧХ на основе переданного набора коэффициентов 
    (полюсов) `a` и `b` передаточной функции. По оси абсцисс откладывается
    нормированная частота. Функция не используется в исходной части 
    лабораторной работы, однако студенты могут использовать её при 
    необходимости.
    
    Parameters
    ----------       
    b : array_like
        Набор коэффициентов (полюсов) знаменателя передаточной функции.
    a : array_like
        Набор коэффициентов (полюсов) числителя передатчоной функции.

    Returns
    -------
    Функция создает графики и ничего не возвращает.
    """

    w,h = freqz(b, a)   # Библиотечная функция для определения комплексной частотной
                        # характеристики h фильтра с полюсами передаточной характеристики
                        # 'b' и 'a'. W - набор частот, которым соответствуют отсчеты h

    h_dB = 20 * np.log10(abs(h)) # Перевод КЧХ в логарифмический масштаб
    
    plt.subplot(211)    # подграфик для АЧХ
    plt.plot(w/max(w), h_dB)
    plt.ylabel('Амлитуда (дБ)')
    plt.xlabel(r'Нормализованная частота (x$\pi$ рад/отсчёт)')
    plt.title(r'АЧХ')
    plt.grid()
    plt.ylim(bottom=-30)
    plt.xlim(lims[0], lims[1])
    
    plt.subplot(212)    # подграфик для ФЧХ
    h_Phase = np.unwrap(np.arctan2(np.imag(h), np.real(h))) # развернутая фаза сигнала 
                                                            # (чтобы не было скачков)
    plt.plot(w/max(w), h_Phase)
    plt.ylabel('Фаза (радианы)')
    plt.xlabel(r'Нормализованная частота (x$\pi$ рад/отсчёт)')
    plt.title(r'ФЧХ')
    plt.xlim(lims[0], lims[1])
    plt.grid()

    plt.subplots_adjust(hspace=1.5)
    plt.show()


# Вывод АЧХ и ФЧХ трех фильтров по его коэффициентам
# на общих осях
def mfreqz3(b: list, a: list, names: list[str], lims: list[int | float]=[0,1]) -> None:
    """
    Вывести по 3 графика АЧХ и ФЧХ на основе переданного набора коэффициентов 
    (полюсов) `a` и `b` передаточной функции. Для построения 3 графиков
    необходимо передать двухмерный массив значений коэффициентов `a` и `b`:
    [[`коэффициенты первого фильтра`], [`коэффициенты второго фильтра`],
    [[`коэффициенты третьего фильтра`]]].
    По оси абсцисс откладывается нормированная частота. Во многом данная
    функция повторяет логику работы mfreqz(), см. её описание выше.
    
    Parameters
    ----------       
    b : array_like
        Набор коэффициентов (полюсов) знаменателя передаточной функции.
    a : array_like
        Набор коэффициентов (полюсов) числителя передаточной функции.
    names : array_like
        Набор названий фильтров, коэффициенты которых переданы в функцию.
    Returns
    -------
    Функция создает графики и ничего не возвращает.
    """
    lines = ["-","--","-.",":"]
    plt.figure()
    plt.subplot(211)
    for i in range(3):
        w, h = freqz(b[i], a[i])
        h_dB = 20 * np.log10(abs(h))
        plt.plot(w/max(w), h_dB, linestyle=lines[i])
        plt.legend(names)
    plt.ylabel('Амплитуда (дБ)')
    plt.xlabel(r'Нормализованная частота (x$\pi$ рад/отсчёт)')
    plt.title(r'АЧХ')
    plt.grid('on')
    plt.ylim(top=1, bottom=-30)
    plt.xlim(lims[0], lims[1])
    
    plt.subplot(212)
    for i in range(3):
        w,h = freqz(b[i], a[i])
        h_Phase = np.unwrap(np.arctan2(np.imag(h), np.real(h)))
        plt.plot(w/max(w), h_Phase, linestyle=lines[i])
        #plt.legend(names)
    plt.xlim(lims[0], lims[1])
    plt.ylabel('Фаза (радианы)')
    plt.xlabel(r'Нормализованная частота (x$\pi$ рад/отсчёт)')
    plt.title(r'ФЧХ')
    plt.grid('on')
    plt.subplots_adjust(hspace=0.5)
    plt.show()
