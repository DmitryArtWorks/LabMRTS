import matplotlib.pyplot as plt
import math
import numpy as np
from scipy.fft import fft, fftshift, ifft
from scipy.signal import butter, lfilter, cheby2, cheby1, freqz
import pywt # С этим модулем могут быть проблемы (может быть не установлен). 
            # Лечение: pip install pywavelets. Несмотря на то, что модуль
            # не используется непосредственно в toolbox, его импорт позволяет
            # отказаться от его импорта непосредственно в ЛР 4.


# Отображение сигналов
def plot_signal(signal_args):
    """
    Вывести действительную часть сигнала, в случае необходимости вывода
    нескольких линий на один график, они передаются в качестве второй
    размерности массива, типа: [[`signal_args` первой линии], 
    [`signal_args` второй линии]]. Одинаковая размерность не обязательна.
    В зависимости от числа переданных аргументов (размерности `signal_args`), 
    функция распознает их следующим образом:

    Parameters
    ----------
    signal_args : array_like
                  Значения по оси ординат (ось OY). В таком случае по оси абсцис (ось OX)
                  будут отложены номера отсчетов.
    signal_args : [array_like or scalar, array_like]
                  Набор значений оси абсцисс или частота дискретизации 
                  в качестве первого аргумента. Значения амплитуд для 
                  оси ординат - в качестве второго.
    signal_args : [array_like or scalar, array_like, string]
                  Первые два аргумента подразумеваются такими же, что и для случая выше. В
                  качестве третьего аргумента передается название линии (пишется в легенде).
    
    Returns
    -------
    Функция создает графики и ничего не возвращает.

    Raises
    ------
    ValueError:
        Если в функцию было передано неверное число аргументов.
    """

    lines = ["-", "--", "-.", ":"] # Список возможных стилей линий графиков
    leg = []
    plt.figure()
    for i in range (len(signal_args)):  # Цикл по числу линий, переданных в функцию
        
        args_len = len(signal_args[i])  # Определяем, сколько аргументов передано для i-ой линии.
        if (args_len > 3 or args_len < 1): # Если аргументов оказалось не столько, сколько ожидалось.
            raise TypeError('Ошибка ввода. Неверное число аргументов (допускается от 1 до 3 аргументов)')
        if (args_len == 1): # Ветка для случая, когда был передан один аргумент (набор значений оси ординат)
            signal = signal_args[i][0]
            x_axis = range(0, len(signal))
        if (args_len == 2 or args_len == 3):
            signal = signal_args[i][1]
            if (type(signal_args[i][0]) == float): # Если в качестве первого аргумента передан шаг дискретизации
                x_axis = np.arange(0, signal_args[i][0]*(len(signal)), signal_args[i][0])
            else:
                x_axis = signal_args[i][1]                
    
        # Построение i-й линии        
        plt.plot(x_axis*1e6, np.real(signal), linestyle=lines[i])
        
        if (args_len == 3):
            leg.append(signal_args[i][2])
        else:
            leg.append('Unnamed signal ' + str(i))  # Если не нравится, можно заменить 
                                                    # содержимое скобок на " ". Работает
                                                    # тоже красиво
        
    plt.legend(leg)
    plt.title('Исходный сигнал')
    plt.xlabel("t, мкc") # ось абсцисс
    plt.grid()
    plt.show()


# Отображение спектр сигнала
def plot_spectum(signal_args):
    """
    Построить график модуля БПФ сигнала, в случае необходимости вывода 
    нескольких линий на один график, они передаются в качестве второй 
    размерности массива, типа: [[`signal_args` первой линии], [`signal_args` второй линии]].
    Одинаковая размерность не обязательна.
    
    Parameters
    ----------       
    signal_args : [scalar, array_like]
                  Частота дискретизации в качестве первого аргумента. 
                  Отсчеты сигнала во временной области - в качестве второго.
    signal_args : [scalar, array_like, string]
                  Первые два аргумента подразумеваются такими же, что и для случая выше. В
                  качестве третьего аргумента передается название линии (пишется в легенде).
    
    Returns
    -------
    Функция создает графики и ничего не возвращает.

    Raises
    ------
    TypeError:
        Если в функцию было передано неверное число аргументов.
    """

    t_d_us = signal_args[0][0]*1e6 # Шаг дискретизации, переведенный в микросекунды
    plt.figure()

    for i in range(len(signal_args)):   # Цикл по числу линий, переданных в функцию
        
        args_len = len(signal_args[i])  # Определяем, сколько аргументов передано для i-ой линии.
        if (args_len > 3 or args_len < 2):  # Если аргументов оказалось не столько, сколько ожидалось.
            raise TypeError('Ошибка ввода. Неверное число аргументов (допускается 2 или 3 аргумента)')
        
        signal = signal_args[i][1]  # Массив значений оси ординат
        n_signal = signal.size  # Способ получить число отсчетов (по сути то же самое, что и len())
        t_window = n_signal*t_d_us  # Вычисление размера окна
        f_step_mhz = 1/t_window # Шаг по частоте (нужен для формирования отсчетов оси абсцисс)
        
        # Формируем точки оси абсцисс графика. Сначала формируем
        # область положительных частот, затем путем отзеркаливания
        # формируется область отрицательных частот.
        # В зависимости от того, четное ли число точек в исходном
        # сигнале, или нечетное, "зеркалится" на 1 отсчет больше или
        # меньше
        if n_signal % 2 == 0:
            f_axis = np.arange(0, (n_signal+1)*f_step_mhz/2, f_step_mhz)
            tmp_axis = np.flip(f_axis[2:]) * (-1) 
            f_axis = np.append(tmp_axis, f_axis)
        else:
            f_axis = np.arange(0, (n_signal)*f_step_mhz/2, f_step_mhz)
            tmp_axis = np.flip(f_axis[1:]) * (-1)
            f_axis = np.append(tmp_axis, f_axis)
        
        # БПФ входных отсчетов, нормированное на число отсчетов
        signal_spectrum = 1/n_signal*fft(signal, n_signal)
        
        # Формирование названий линий
        if (len(signal_args[i]) > 2):
            line_label = str(signal_args[i][2])
        else:
            line_label = 'Unnamed spectrum ' + str(i)   # Выражение может быть заменено 
                                                        # на: ' '(пробел в кавычках)
            
        plt.plot(f_axis, fftshift(abs(signal_spectrum)), label=line_label)  # построение i-й линии
    plt.title("Спектр") # заголовок
    plt.xlabel("Частота, МГц") # ось абсцисс        
    plt.legend()
    plt.grid()
    plt.show()


# Вывод ИХ фильтра по его коэффициентам
def impz(b, a, name):
    """
    Вывести график импульсной характеристики на основе переданного набора коэффициентов 
    (полюсов) `a` и `b` передаточной функции.
    
    Parameters
    ----------       
    b : array_like
        Набор коэффициентов (полюсов) знаменателя передаточной функции.
    a : array_like
        Набор коэффициентов (полюсов) числителя передатчоной функции.
    name : string
        Название графика.
    Returns
    -------
    Функция создает графики и ничего не возвращает.
    """

    impulse = [0]*100   # impulse - массив отсчетов входного воздействия на фильтр (импульса).
                        # [0]*100 - это способ задать 100 одинаковых элементов (в данном
                        # случае - нулей)
    impulse[0] =1.  # Один из ста отсчетов будет иметь единичное значение. Получится своеобразный
                    # импульс.
    x = range(100)  # Набор значений оси абсцисс для построения графика
    response = lfilter(b, a, impulse)   # Библиотечная функция вычисления отлика фильтра с полюсами
                                        # передаточной хар-ки 'a', 'b' на входное воздействие 'impulse'
    plt.stem(x, response)
    plt.ylabel('Amplitude')
    plt.xlabel(r'n (samples)')
    plt.title(name)
    plt.show()


# Вывод АЧХ и ФЧХ фильтра по его коэффициентам
def mfreqz(b, a):
    """
    Вывести графики АЧХ и ФЧХ на основе переданного набора коэффициентов 
    (полюсов) `a` и `b` передаточной функции. По оси абсцисс откладывается
    нормированная частота. Функция не используется в исходной части 
    лабораторной работы, однако студенты могут использовать её при 
    необходимости.
    
    Parameters
    ----------       
    b : array_like
        Набор коэффициентов (полюсов) знаменателя передаточной функции.
    a : array_like
        Набор коэффициентов (полюсов) числителя передатчоной функции.

    Returns
    -------
    Функция создает графики и ничего не возвращает.
    """
    w,h = freqz(b, a)   # Библиотечная функция для определения комплексной частотной
                        # характеристики h фильтра с полюсами передаточной характеристики
                        # 'b' и 'a'. W - набор частот, которым соответствуют отсчеты h
    h_dB = 20 * np.log10(abs(h)) # Перевод КЧХ в логарифмический масштаб
    
    plt.subplot(211)    # подграфик для АЧХ
    plt.plot(w/max(w), h_dB)
    plt.ylabel('Magnitude (db)')
    plt.xlabel(r'Normalized Frequency (x$\pi$rad/sample)')
    plt.title(r'Frequency response')
    plt.grid()
    plt.ylim(bottom=-30)
    
    plt.subplot(212)    # подграфик для ФЧХ
    h_Phase = np.unwrap(np.arctan2(np.imag(h), np.real(h)))
    plt.plot(w/max(w), h_Phase)
    plt.ylabel('Phase (radians)')
    plt.xlabel(r'Normalized Frequency (x$\pi$rad/sample)')
    plt.title(r'Phase response')
    plt.grid()

    plt.subplots_adjust(hspace=1.5)
    plt.show()


# Вывод АЧХ и ФЧХ фильтра по его коэффициентам
def mfreqz3(b, a, names, lims=[0,1]):
    """
    Вывести по 3 графика АЧХ и ФЧХ на основе переданного набора коэффициентов 
    (полюсов) `a` и `b` передаточной функции. Для построения 3 графиков
    необходимо передать двухмерный массив значений коэффициентов `a` и `b`:
    [[`коэффициенты первого фильтра`], [`коэффициенты второго фильтра`],
    [[`коэффициенты третьего фильтра`]]].
    По оси абсцисс откладывается нормированная частота. Во многом данная
    функция повторяет логику работы mfreqz(), см. её описание выше.
    
    Parameters
    ----------       
    b : array_like
        Набор коэффициентов (полюсов) знаменателя передаточной функции.
    a : array_like
        Набор коэффициентов (полюсов) числителя передаточной функции.
    names : array_like
        Набор названий фильтров, коэффициенты которых переданы в функцию.
    Returns
    -------
    Функция создает графики и ничего не возвращает.
    """
    lines = ["-","--","-.",":"]
    
    plt.subplot(211)
    for i in range(3):
        w, h = freqz(b[i], a[i])
        h_dB = 20 * np.log10(abs(h))
        plt.plot(w/max(w), h_dB, linestyle=lines[i])
        plt.legend(names)
    plt.ylabel('Magnitude (db)')
    plt.xlabel(r'Normalized Frequency (x$\pi$rad/sample)')
    plt.title(r'Frequency response')
    plt.grid('on')
    plt.ylim(top=1, bottom=-30)
    plt.xlim(lims[0], lims[1])
    
    plt.subplot(212)
    for i in range(3):
        w,h = freqz(b[i], a[i])
        h_Phase = np.unwrap(np.arctan2(np.imag(h), np.real(h)))
        plt.plot(w/max(w), h_Phase, linestyle=lines[i])
        #plt.legend(names)
    plt.xlim(lims[0], lims[1])
    plt.ylabel('Phase (radians)')
    plt.xlabel(r'Normalized Frequency (x$\pi$rad/sample)')
    plt.title(r'Phase response')
    plt.grid('on')
    plt.subplots_adjust(hspace=0.5)
    plt.show()


""" Генерация импульсов 
Функции генерации последовательности импульсов и одиночного импульса
"""


# Формирование последовательности чипов
def generate_sequence(sig_type, t_d, n_chips, t_imp, f_low):
    """
    Сформировать отсчеты последовательности одного из следующих сигналов:
    радиоимпульс `radio`, АМ сигнал `AM`, ЛЧМ сигнал `chirp`. Функция 
    представляет собой обертку вокруг функций, которые непосредственно 
    формируют сигналы. В отличие от generate_single_chip() не создает 
    видеоимпульс, обладает фиксированным набором входных параметров и 
    создает отсчеты для нескольких периодов сигнала.
    
    Parameters
    ----------       
    signal_type : 'radio', 'AM', 'chirp'
        Вид сигнала, отсчеты которого необходимо сформировать.
    t_d : scalar
        Интервал дискретизации сигнала.
    n_chips : scalar
        Число периодов сигнала, которые необходимо отобразить.
    t_imp : scalar
        Длительность огибающей импульса.
    f_low : scalar
        Минимальная частотаю Параметр крайне условный, поскольку
        для каждого сигнала этот затем преобразуется по-разному. 

    Returns
    -------
    signal : array_like
        Набор отсчетов сигнала требуемого типа.
    
    Raises
    -------
    ValueError
        Если в аргумент `signal_type `был передан неверный тип сигнала.

    """
    n_cnts_sig = math.floor(t_imp/t_d)  # Определение числа отсчетов, приходящихся
                                        # на один из n_chips периодов сигнала.

    res_sig = np.array([0]) # Инициализация выходного массива

    sig = [0] * n_cnts_sig  # инициализация внутренней переменной, необходимой для
                            # работы выбранного алгоритма формирования последовательности
                            # импульсов.
    
    # Выбор вызываемой функции в зависимости от значения sig_type
    if (sig_type == 'chirp'): # тип ЛЧМ импульс
        f_mod = f_low/5
        for _ in range(0, n_chips): # Цикл по числу периодов
            sig[:n_cnts_sig] = get_chirp_pulse(t_d, t_imp, 0.96*t_imp, f_low, f_mod)    # формирование отсчетов для одного периода сигнала.
                                                                                        # `t_window` = t_imp, `t_imp` = 0.96*t_imp, чтобы 
                                                                                        # импульс был равен ПОЧТИ всему времени наблюдения.
                                                                                        # Это нужно, чтобы импульсы были визуально различимы 
                                                                                        # на графике.
            res_sig = np.append(res_sig, sig)   # конкатенация очередного периода к
                                                # коцу массива res_sig

    elif (sig_type == 'radio'): # тип р/импульс
        for _ in range(0, n_chips): # Цикл по числу периодов
            random_freq = f_low + np.random.randint(5, size=(1))*8/t_imp # случайная частота несущей р/импульса
            sig[:n_cnts_sig] = get_radio_pulse(t_d, t_imp, 0.96*t_imp, random_freq) # формирование отсчетов для одного периода сигнала.
                                                                                    # `t_window` = t_imp, `t_imp` = 0.96*t_imp, чтобы 
                                                                                    # импульс был равен ПОЧТИ всему времени наблюдения.
                                                                                    # Это нужно, чтобы импульсы были визуально различимы 
                                                                                    # на графике.
            res_sig = np.append(res_sig, sig)   # конкатенация очередного периода к
                                                # коцу массива res_sig
        
    elif (sig_type == 'AM'): # АМ сигнал
        f_mod = f_low/10
        for _ in range(0, n_chips): # Цикл по числу периодов
            random_freq = f_low + np.random.randint(5, size=(1))*(3*f_mod) # случайная частота несущей АМ сигнала
            sig[:n_cnts_sig] = get_AM(t_d, t_imp, random_freq, f_mod, 0.5) # формирование отсчетов для одного периода сигнала.
            res_sig = np.append(res_sig, sig)   # конкатенация очередного периода к
                                                # коцу массива res_sig
    else:
        raise ValueError("Введён неверный тип сигнала. Допустимы значения: 'video', 'radio', 'AM', 'chirp'")
    
    res_sig = np.delete(res_sig, 0) # удаление нулевого отсчета сигнала, который использовался для инициализации массива
        
    return res_sig


# Формирование сигналов (управляющая функция)
def generate_single_chip(signal_type, *signal_data): # запустить функцию формирования сигнала в зависимости от заданного типа
    """
    Сформировать отсчеты одного периода одного из следующих сигналов:
    видеоимпульс `video`, радиоимпульс `radio`, АМ сигнал `AM`, ЛЧМ 
    сигнал `chirp`. Для каждого из видов сигнала необходимо передать 
    в функцию разный набор параметров. Функция представляет собой 
    обертку вокруг функций, которые непосредственно формируют сигналы.
    
    Parameters
    ----------       
    signal_type : 'video', 'radio', 'AM', 'chirp'
        Вид сигнала, отсчеты которого необходимо сформировать.
    *signal_data : list of scalars ####################################### TODO: Мне не нравится, как я это назвал. По сути же передается не list, а просто последовательность несвязанных переменных
        Набор параметров, которые необходимо передать для формирования
        требуемого вида сигнала. 
        Для видеоимпульса 'video': `t_d`, `t_window`, `t_imp`;
        Для радиоимпульса 'radio': `t_d`, `t_window`, `t_imp`, `f_carrier_hz`;
        Для AM: `t_d`, `t_window`, 'f_carrier_hz', `f_mod_hz`, `i_mod`;
        Для ЛЧМ: `t_d`, `t_window`, `t_imp`, `f_start_hz`, `f_chirp_hz`,
        где 
            `t_d` - интервал дискретизации сигнала;
            `t_window` - интервал наблюдения сигнала;
            `t_imp` - длительность огибающей импульса;
            `f_carrier_hz` - частота заполнения сигнала;
            `f_mod_hz` - частота модулирующего сигнала;
            `i_mod` - глубина модуляции (индекс модуляции);
            `f_start_hz` - центральная частота ЛЧМ сигнала;
            `f_chirp_hz` - частота девиации ЛЧМ сигнала.
    Returns
    -------
    signal : array_like
        Набор отсчетов сигнала требуемого типа.
    
    Raises
    -------
    ValueError
        Если в аргумент `signal_type `был передан неверный тип сигнала.

    """
    # Выбор вызываемой функции в зависимости от значения sig_type
    if (signal_type == 'video'):    # тип в/импульс
        signal = get_video_pulse(*signal_data)
    elif (signal_type == 'radio'):  # тип р/импульс
        signal = get_radio_pulse(*signal_data)
    elif (signal_type == 'AM'): # тип АМ сигнал  
        signal = get_AM(*signal_data)
    elif (signal_type == 'chirp'):  # тип ЛЧМ сигнал
        signal = get_chirp_pulse(*signal_data)
    else:
        raise ValueError("Введён неверный тип сигнала. Допустимы значения: 'video', 'radio', 'AM', 'chirp'")
    
    return signal


# Функции формирования чипа
# Формирование в/импульса
def get_video_pulse(t_d, t_window, t_imp):
    """
    Сформировать отсчеты видеоимпульса единичной амплитуды. 
    Он будет помещен в самом начале "временной" оси.
    
    Parameters
    ----------       
    t_d : scalar
        Интервал дискретизации сигнала.
    t_window : scalar
        Длительность "окна", в котором наблюдается сигнал.
    t_imp : scalar
        Длительность создаваемого импульса.
    
    Returns
    -------
    signal : array_like
        Набор отсчетов видеоимпульса.
    """

    n_signal = math.floor(t_window/t_d)  # число отсчетов в рассматриваемом интерв.
    n_imp = math.floor(t_imp/t_d)        # число отсчетов импульса
    signal = [0] * n_signal              # сформировать пустую выборку
    for i in range(0, n_imp):     # поставить первые n_imp отсчетов
        signal[i] = 1
    return signal


# Формирование р/импульса
def get_radio_pulse(t_d, t_window, t_imp, f_carrier_hz):
    """
    Сформировать отсчеты радиоимпульса единичной амплитуды. 
    Он будет помещен в самом начале "временной" оси.
    
    Parameters
    ----------       
    t_d : scalar
        Интервал дискретизации сигнала.
    t_window : scalar
        Длительность "окна", в котором наблюдается сигнал.
    t_imp : scalar
        Длительность создаваемого импульса.
    f_carrier_hz : scalar
        Частота несущей, "заполняющей" видеосигнал.

    Returns
    -------
    signal : array_like
        Набор отсчетов радиоимпульса.
    """
    n_signal = math.floor(t_window/t_d) # число отсчетов в рассматриваемом интерв.
    n_imp = math.floor(t_imp/t_d)   # число отсчетов импульса
    pulse_amp = [0] * n_signal  # сформировать пустую выборку
    for i in range(1, n_imp):   # сформировать огибающую радиоимпульса
        pulse_amp[i] = 1
    t_axis = np.linspace(0, t_window, n_signal) # формирование временной оси
    carrier = np.sin(2*math.pi*f_carrier_hz*t_axis) # сформировать несущую
    signal = pulse_amp*carrier  # несущая на амплитудные значения
    return signal


# Формирование АМ/сигнала
def get_AM(t_d, t_window, f_carrier_hz, f_mod_hz, i_mod):
    """
    Сформировать отсчеты АМ сигнала.
    
    Parameters
    ----------       
    t_d : scalar
        Интервал дискретизации сигнала.
    t_window : scalar
        Длительность "окна", в котором наблюдается сигнал.
    t_imp : scalar
        Длительность создаваемого импульса.
    f_carrier_hz : scalar
        Частота несущей, "заполняющей" видеосигнал.
    f_mod_hz : scalar
        Частота модулирующей синусоиды.
    i_mod : scalar
        Индекс (глубина) модуляции сигнала

    Returns
    -------
    signal : array_like
        Набор отсчетов АМ сигнала.
    """

    n_signal = math.floor(t_window/t_d) # число отсчетов в интервале рассмот.
    t_axis = np.linspace(0, t_window, n_signal) # ось времени
    am_mult = 1/(2/i_mod) 
    am_shift = 1-am_mult    # множитель для расчета огибающей АМ
    a_modulation = np.sin(2*math.pi*f_mod_hz*t_axis)*am_mult+am_shift   # огибающая
    signal = np.sin(2*math.pi*f_carrier_hz*t_axis) * a_modulation   # формирование АМ сигнала

    return signal


# Формирование ЛЧМ
def get_chirp_pulse(t_d, t_window, t_imp, f_start_hz, f_chirp_hz):
    """
    Сформировать отсчеты "ЛЧМ" сигнала (в стадии разработки).
    
    Parameters
    ----------       
    t_d : scalar
        Интервал дискретизации сигнала.
    t_window : scalar
        Длительность "окна", в котором наблюдается сигнал.
    t_imp : scalar
        Длительность создаваемого импульса.
    f_start_hz : scalar
        Начальная (и по совместительству - несущая) частота сигнала.
    f_chirp_hz : scalar
        Частота девиации.

    Returns
    -------
    signal : array_like
        Набор отсчетов ЛЧМ сигнала.
    """
    n_signal = math.floor(t_window/t_d)     # число отсчетов в рассматриваемом интерв.
    n_imp = math.floor(t_imp/t_d)           # число отсчетов импульса
    t_axis = np.linspace(0, t_imp, n_imp)   # формирование временной оси
    chirp_band = f_chirp_hz/t_imp
    chirp_sin_arg = f_start_hz + chirp_band/2*t_axis
    signal = [0] * n_signal
    signal[1:n_imp+1] = np.sin(2*math.pi*chirp_sin_arg*t_axis)     # сформировать несущую
    
    return signal


""" Фильтры 
"""


# Применить к сигналу фильтр с "идеальной" АЧХ
def apply_ideal_filter(t_d, filter_type, f_cut_hz, signal_in):
    """
    Применить к сигналу один из фильтров (ФНЧ, ФВЧ, ЗФ, ПФ) с 
    идеальной АЧХ (1 - в полосе пропускания, 0 - в полосе подавления, 
    переходной полосы нет). Принцип работы следующий: формируется
    идеальная АЧХ фильтра в области положительных частот, а затем
    с помощью `np.flip()` и конкатенации получается АЧХ для всего
    диапазона частот (и положительных, и отрицательных). Для получения
    выходного сигнала производится перемножение АЧХ фильтра с АЧХ входного
    сигнала.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    signal_in : array_like (real)
        Отсчеты входного действительного сигнала.  
    
    Returns
    -------
    Функция возвращает отсчеты отфильтрованного идеальным `filter_type` 
    фильтром сигнала `signal_in`.

    Raises
    ------
    TypeError:
        Если в функцию было передано неправильное название фильтра
        или граничные частоты фильтра. Или выходной сигнал получился
        комплексным.
    
    ValueError:
        Если в случае фильтра с двумя частотами среза список частот
        не был упорядочен в порядке возрастания.          
    """

    f_d = 1/t_d    # вычисление частоты дискретизации (обратно пропорционально интервалу дискретизации)
    n_signal = len(signal_in) # определение числа отсчетов
    f_axis = np.linspace(0, f_d/2, int(np.floor(n_signal / 2))) # половина набора отсчетов оси абсцисс АЧХ.
                                                                # Вторая половина будет получена с помощью
                                                                # np.flip().
    filter_f_char = np.ones(int(np.ceil((n_signal+1)/2)))   # половина набора отсчетов оси ординат АЧХ.
                                                            # Вторая половина будет получена с помощью
                                                            # np.flip().
    
    if isinstance(f_cut_hz, float or int): # Если одно значение частоты среза, то это будет или ФНЧ, или ФВЧ.
           
        f_cut_i = np.argmax(f_axis > f_cut_hz)  # Выражение f_axis > f_cut_hz дает логический массив, элементами
                                                # которого являются результат сравнения значения f_axis с f_cut_hz
                                                # np.argmax() находит индекс первого максимального значения, который
                                                # будет соответствовать номеру элемента, в котором расположилась 
                                                # частота среза. Такая, на первый взгляд, сложность обусловлена тем, 
                                                # что число отсчетов входного сигнала не является постоянным, как и
                                                # частота среза.
        if (filter_type == 'HP'): 
            filter_f_char[:f_cut_i] = 0     # Если необходимо сформировать ФВЧ, то все отсчеты АЧХ, сответствующие
                                            # частотам ниже частоты среза должны быть равны нулю.
        elif (filter_type == 'LP'): 
            filter_f_char[f_cut_i:] = 0     # Если необходимо сформировать ФНЧ, то все отсчеты АЧХ, соответствующие  
                                            # частотам выше частоты среза должны быть равны нулю.
        else:   
            raise ValueError('Ошибка вввода: Тип фильтра')   # Вызов исключения, если был передан неизвестный
                                                            # аргумент.

        # формирование АЧХ для двухстороннего спектра со второго с начала отсчета.
        tmp_filter_f_char = np.flip(filter_f_char[1:])  # "Переворот" (но не гражданский) массива АЧХ, поскольку
                                                        # АЧХ в отрицательной области "зеркальна" АЧХ в положительной.
                                                        # Опускаем 0-й элемент, поскольку в противном случае получится
                                                        # два отсчета, отвечающих за значение АЧХ на нулевой частоте.
        if (n_signal % 2 == 0): 
            tmp_filter_f_char = tmp_filter_f_char[:len(tmp_filter_f_char) - 1]  # Если количество отсчетов сигнала четное, то
                                                                                # необходимо исключить последний отсчет АЧХ, т.к
                                                                                # он лишний, а появился из-за выбранного способа
                                                                                # формирования массива filter_f_char (мы округляли)
                                                                                # "вверх" число элементов этого массива.
        filter_f_char = np.append(filter_f_char, tmp_filter_f_char) # Конкатенация отрицательной и положительной 
                                                                    # частей АЧХ в один массив.
    
    elif isinstance(f_cut_hz, list):    # Если два значения частоты среза, то ПФ или ЗФ
        
        if f_cut_hz[0] > f_cut_hz[1]:   # Для корректной работы необходимо, чтобы нулевой 
                                        # элемент массива частот был меньше первого.
            raise ValueError('Ошибка: f_cut_hz[0] должна быть меньше f_cut_hz[1]')
        
        f_cut_0 = np.argmax(f_axis > f_cut_hz[0])   # Принцип тот же, как и в ветке с одной частотой среза. 
        f_cut_1 = np.argmax(f_axis > f_cut_hz[1])   # Однако поскольку у данных фильтров две частоты среза, 
                                                    # необходимо найти индексы, соответствующие этим двум
                                                    # частотам. 
        if (filter_type == 'BP'):
            filter_f_char[:f_cut_0] = 0 # Если необходимо сформировать АЧХ ПФ, то все отсчеты, соответствующие
            filter_f_char[f_cut_1:] = 0 # частотам ниже f_cut_0 и выше f_cut_1 должны равняться нулю.
        elif (filter_type == 'BS'): 
            filter_f_char[f_cut_0:f_cut_1] = 0  # Если необходимо сформировать АЧХ ПФ, то все отсчеты, соответствующие
                                                # интервалу частот f_cut_0...f_cut_1 должны равняться нулю.
        tmp_filter_f_char = np.flip(filter_f_char[1:])  # "Переворот" (но не гражданский) массива АЧХ, поскольку
                                                        # АЧХ в отрицательной области "зеркальна" АЧХ в положительной.
                                                        # Опускаем 0-й элемент, поскольку в противном случае получится
                                                        # два отсчета, отвечающих за значение АЧХ на нулевой частоте.
        if (n_signal % 2 == 0):
            tmp_filter_f_char = tmp_filter_f_char[:len(tmp_filter_f_char) - 1]  # Если количество отсчетов сигнала четное, то
                                                                                # необходимо исключить последний отсчет АЧХ, т.к
                                                                                # он лишний, а появился из-за выбранного способа
                                                                                # формирования массива filter_f_char (мы округляли)
                                                                                # "вверх" число элементов этого массива.
        filter_f_char = np.append(filter_f_char, tmp_filter_f_char) # Конкатенация отрицательной и положительной 
                                                                    # частей АЧХ в один массив.
    else:
        raise ValueError('Ошибка ввода: Граничные частоты фильтра')  # В эту ветку код свалится, если f_cut_hz имело
                                                                    # тип данных, который не ожидался (в идеале ожидается)
                                                                    # либо скаляр (int/float) или list из 2 элементов
    # Фильтрация входного сигнала
    signal_in_sp = fft(signal_in, n_signal) # АФЧХ входного сигнала
    signal_out_sp = signal_in_sp * filter_f_char    # АФЧХ выходного сигнала (произведение)
                                                    # АФЧХ выходного сигнала на АФЧХ фильтра
    signal_out = ifft(signal_out_sp, n_signal)  # Выходной сигнал во временно`й области
    
    # Данная ветка будет вызвана, если по какой-то причине выходной сигнал 
    # оказался комплексным (должен быть действительным, поскольку на входе)
    # он действительный
    if (np.prod(np.iscomplex(signal_out))): 
        raise TypeError('Допущена ошибка при формировании фильтра: сигнал после фильтрации комплексный')  
    return signal_out


# Применить к сигналу фильтр Баттерворта
def apply_butt_filter(t_d, filter_type, f_cut_hz, filter_order, signal_in):
    """
    Применить к сигналу один из фильтров (ФНЧ, ФВЧ, ЗФ, ПФ) с 
    максимально гладкой АЧХ (фильтр Баттерворта). Функция опирается 
    на библиотечные функции по определению коэффициентов фильтра, 
    а также непосредственно фильтрации сигнала.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    filter_order : scalar
        Порядок фильтра. Чем выше порядок, тем круче спад АЧХ в переходной 
        полосе.
    signal_in : array_like (real)
        Отсчеты входного действительного сигнала.  
    
    Returns
    -------
    Функция возвращает отсчеты сигнала `signal_in` после прохождения через фильтр
    Баттерворта типа `filter_type`.         
    """
    # формирование коэффициентов числителя и знаменателя фильтра Баттерворта
    b, a = create_butt_filter(t_d, filter_type, f_cut_hz, filter_order)  
    
    signal_out = lfilter(b, a, signal_in)   # фильтрация сигнала
    return signal_out


# Применить к сигналу фильтр Чебышёва
def apply_cheb2_filter(t_d, filter_type, f_cut_hz, filter_order, bnd_att_db, signal_in):
    """
    Применить к сигналу один из фильтров (ФНЧ, ФВЧ, ЗФ, ПФ) с 
    АЧХ, описываемой полиномом Чебышева II типа (фильтр Чебышева).
    Функция опирается на библиотечные функции по определению 
    коэффициентов фильтра, а также непосредственно фильтрации сигнала.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    filter_order : scalar
        Порядок фильтра. Чем выше порядок, тем круче спад АЧХ в переходной 
        полосе.
    signal_in : array_like (real)
        Отсчеты входного действительного сигнала.  
    
    Returns
    -------
    Функция возвращает отсчеты сигнала `signal_in` после прохождения через фильтр
    Баттерворта типа `filter_type`.         
    """
    b, a = create_cheb2_filter(t_d, filter_type, f_cut_hz, filter_order, bnd_att_db)    # формирование фильтра
    
    signal_out = lfilter(b, a, signal_in)   # фильтрация сигнала
    return signal_out


# Расчет коэффициентов фильтра Баттерворта
def create_butt_filter(t_d, filter_type, f_cut_hz, filter_order):
    """
    Определить коэффициенты передаточной функции фильтра с максимально
    гладкой АЧХ (фильтра Баттерворта). Функция опирается на библиотечные
    функции по определению коэффициентов фильтра.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    filter_order : scalar
        Порядок фильтра. Чем выше порядок, тем круче спад АЧХ в переходной 
        полосе.
    
    Returns
    -------
    Функция возвращает коэффициенты числителя `a` и знаменателя `b` передаточной
    функции фильтра. 

    Raises
    -------
    ValueError: 
        Если введён неправильный тип фильтра.     
    """
    # Ветка условий конвертирует обозначения фильтров, которые используются
    # в лабе, в значения, требующиеся библиотечной функции.
    if (isinstance(f_cut_hz, float or int)):    # если передано одно зачение частоты среза, то:
        if (filter_type == 'LP'):
            f_name = 'lowpass'  # НЧ фильтр
        elif (filter_type == 'HP'):
            f_name = 'highpass' # ВЧ фильтр
        else:
            raise ValueError('Ошибка вввода: Тип фильтра')
    elif (isinstance(f_cut_hz, list)):  # если передано два значения частот среза, то:
        if (filter_type == 'BP'):
            f_name = 'bandpass' # Полосовой фильтр
        elif (filter_type == 'BS'):
            f_name = 'bandstop' # Заградительный фильтр
        else:
            raise ValueError('Ошибка вввода: Тип фильтра')
    else:
        raise ValueError('Ошибка ввода: Граничные частоты фильтра')
    
    f_d = 1/t_d # частота дискретизации
    w_n = np.array(f_cut_hz)/(f_d/2)    # нормированная частота среза.
                                        # Нужна для работы библиотечной функции
    b, a = butter(filter_order, w_n, f_name)    # формирование коэффициентов фильтра Баттерворта
                                                # с помощью библиотечной функции.
    return b, a


# Расчет коэффициентов Фильтра Чебышева
def create_cheb2_filter(t_d, filter_type, f_cut_hz, filter_order, bnd_att_db):
    """
    Определить коэффициенты передаточной функции фильтра, описываемого полиномом
    Чебышева II рода (фильтра Чебышева II рода). У данного фильтра присутствуют 
    пульсации АЧХ в `полосе заграждения`. `Полоса пропускания` при этом гладкая. 
    Функция опирается на библиотечные функции по определению коэффициентов фильтра.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    filter_order : scalar
        Порядок фильтра. Чем выше порядок, тем круче спад АЧХ в переходной 
        полосе.
    
    Returns
    -------
    Функция возвращает коэффициенты числителя `a` и знаменателя `b` передаточной
    функции фильтра. 

    Raises
    -------
    ValueError: 
        Если введён неправильный тип фильтра.     
    """
    # Ветка условий конвертирует обозначения фильтров, которые используются
    # в лабе, в значения, требующиеся библиотечной функции.
    if isinstance(f_cut_hz, float or int):      # если передано одно зачение частоты среза, то:
        if (filter_type == 'LP'):
            f_name = 'lowpass'  # НЧ фильтр
        elif (filter_type == 'HP'):
            f_name = 'highpass' # ВЧ фильтр
        else:
            raise ValueError('Ошибка вввода: Тип фильтра') # если передано два значения частот среза
    elif (isinstance(f_cut_hz, list)):
        if (filter_type == 'BP'):
            f_name = 'bandpass' # полосовой фильтр
        elif (filter_type == 'BS'):
            f_name = 'bandstop' # заградительный фильтр
        else:
            raise ValueError('Ошибка вввода: Тип фильтра')

    else:
        raise ValueError('Ошибка ввода: Граничные частоты фильтра')

    f_d = 1/t_d # частота дискретизации, Гц
    w_n = np.array(f_cut_hz)/(f_d/2)    # нормированная частота среза (w/w_d). Нужна 
                                        # для работы библиотечной функции.
    b, a = cheby2(filter_order, bnd_att_db, w_n, f_name)    # формирование фильтра с помощью библиотечной функции.
    return b, a


def create_cheb1_filter(t_d, filter_type, f_cut_hz, filter_order, bnd_att_db):
    """
    Определить коэффициенты передаточной функции фильтра, описываемого полиномом
    Чебышева I рода (фильтра Чебышева I рода). У данного фильтра присутствуют пульсации
    АЧХ в `полосе пропускания`. `Полоса заграждения` при этом гладкая.
    Функция опирается на библиотечные функции по определению коэффициентов фильтра.
    
    Parameters
    ----------       
    t_d : scalar
        Шаг дискретизации. 
    filter_type : 'LP', 'HP', 'BP', 'BS'
        Тип фильтра: фильтр нижних частот, ФНЧ - `'LP'`; фильтр верхних частот,
        ФВЧ - `'HP'`, полосовой фильтр, ПФ - `'BP'`, заградительный фильтр, ЗФ - 
        `'BS'`.
    f_cut_hz : scalar or list
        Одна частота среза для ФНЧ и ФВЧ или две частоты среза для ПФ и ЗФ. 
        Если передать list с числом элементов более 2, все элементы, кроме
        первых двух, будут проигнорированы.
    filter_order : scalar
        Порядок фильтра. Чем выше порядок, тем круче спад АЧХ в переходной 
        полосе.
    
    Returns
    -------
    Функция возвращает коэффициенты числителя `a` и знаменателя `b` передаточной
    функции фильтра. 

    Raises
    -------
    ValueError: 
        Если введён неправильный тип фильтра.     
    """
    # Ветка условий конвертирует обозначения фильтров, которые используются
    # в лабе, в значения, требующиеся библиотечной функции.
    if isinstance(f_cut_hz, float):      # если передано одно зачение частоты среза
        if (filter_type == 'LP'):
            f_name = 'lowpass'           # НЧ фильтр
        elif (filter_type == 'HP'):
            f_name = 'highpass'          # ВЧ фильтр
        else:
            raise ValueError('Ошибка вввода: Тип фильтра') # если передано два значения частот среза
    elif (isinstance(f_cut_hz, list)):
        if (filter_type == 'BP'):
            f_name = 'bandpass'                 # полосовой фильтр
        elif (filter_type == 'BS'):
            f_name = 'bandstop'                 # заградительный фильтр
        else:
            raise ValueError('Ошибка вввода: Тип фильтра')

    else:
        raise ValueError('Ошибка ввода: Граничные частоты фильтра')
        
    f_d = 1/t_d            # частота дискретизации, Гц
    w_n = np.array(f_cut_hz)/(f_d/2)    # нормированная частота среза (w/w_d). Нужна для
                                        # работы библиотечной функции
    b, a = cheby1(filter_order, bnd_att_db, w_n, f_name)  # формирование фильтра
    return b, a

